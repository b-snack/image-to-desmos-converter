<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image to Desmos - Browser Version</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
        }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            background: #f8f9ff;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 30px;
        }
        
        .upload-area:hover {
            background: #f0f2ff;
            border-color: #764ba2;
        }
        
        .upload-area.dragover {
            background: #e8ebff;
            border-color: #764ba2;
        }
        
        #fileInput {
            display: none;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .control-group label {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            display: block;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
            width: 100%;
            margin: 10px 0;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .preview-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .preview-box {
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 15px;
        }
        
        .preview-box h3 {
            margin-bottom: 10px;
            color: #667eea;
            text-align: center;
        }
        
        canvas {
            display: block;
            max-width: 100%;
            margin: 0 auto;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .output-box {
            background: #f8f9ff;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        #expressionsList {
            max-height: 400px;
            overflow-y: auto;
            background: white;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }
        
        .expression {
            background: #f8f9ff;
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            word-break: break-all;
            cursor: pointer;
            border-left: 4px solid #667eea;
        }
        
        .expression:hover {
            background: #e8f0ff;
        }
        
        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: 600;
        }
        
        .status.success {
            background: #e8f5e9;
            color: #388e3c;
        }
        
        .status.info {
            background: #e3f2fd;
            color: #1976d2;
        }
        
        .hidden {
            display: none;
        }
        
        .progress {
            background: #e0e0e0;
            border-radius: 10px;
            height: 30px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-bar {
            background: linear-gradient(90deg, #667eea, #764ba2);
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¨ Image to Desmos - Browser Version</h1>
        <p class="subtitle">Upload an image and trace its outlines into Desmos code</p>
        
        <div class="upload-area" id="uploadArea">
            <div style="font-size: 3em; margin-bottom: 15px;">ðŸ“¸</div>
            <h3>Click or drag an image here</h3>
            <p style="color: #666; margin-top: 10px;">Works best with anime, line art, or high-contrast images</p>
            <input type="file" id="fileInput" accept="image/*">
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>Edge Threshold (Low): <span id="lowValue">30</span></label>
                <input type="range" id="edgeLow" min="10" max="100" value="30">
                <small>Lower = more faint lines</small>
            </div>
            
            <div class="control-group">
                <label>Edge Threshold (High): <span id="highValue">100</span></label>
                <input type="range" id="edgeHigh" min="50" max="200" value="100">
                <small>Controls sensitivity</small>
            </div>
            
            <div class="control-group">
                <label>Output Width: <span id="widthValue">300</span>px</label>
                <input type="range" id="outputWidth" min="100" max="500" value="300" step="50">
                <small>Size in Desmos</small>
            </div>
            
            <div class="control-group">
                <label>Simplification: <span id="simplifyValue">2</span></label>
                <input type="range" id="simplify" min="1" max="10" value="2">
                <small>Higher = smoother lines</small>
            </div>
        </div>
        
        <button id="convertBtn" disabled>Extract Lines & Convert to Desmos</button>
        
        <div id="progress" class="progress hidden">
            <div id="progressBar" class="progress-bar">0%</div>
        </div>
        
        <div id="status" class="hidden"></div>
        
        <div id="previewSection" class="preview-container hidden">
            <div class="preview-box">
                <h3>Original Image</h3>
                <canvas id="originalCanvas"></canvas>
            </div>
            <div class="preview-box">
                <h3>Detected Edges</h3>
                <canvas id="edgeCanvas"></canvas>
            </div>
        </div>
        
        <div id="outputSection" class="hidden">
            <div class="output-box">
                <h3>ðŸ“‹ Desmos Code - Copy & Paste into Desmos:</h3>
                <div style="display: flex; gap: 10px; margin-top: 15px;">
                    <button id="copyAllBtn" style="flex: 1; margin: 0;">Copy All Expressions</button>
                    <button id="downloadBtn" style="flex: 1; margin: 0;">Download .txt</button>
                </div>
                <div id="expressionsList"></div>
            </div>
        </div>
    </div>

    <script>
        let currentImage = null;
        
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const convertBtn = document.getElementById('convertBtn');
        const progress = document.getElementById('progress');
        const progressBar = document.getElementById('progressBar');
        const status = document.getElementById('status');
        const previewSection = document.getElementById('previewSection');
        const originalCanvas = document.getElementById('originalCanvas');
        const edgeCanvas = document.getElementById('edgeCanvas');
        const outputSection = document.getElementById('outputSection');
        const expressionsList = document.getElementById('expressionsList');
        
        const edgeLowSlider = document.getElementById('edgeLow');
        const edgeHighSlider = document.getElementById('edgeHigh');
        const widthSlider = document.getElementById('outputWidth');
        const simplifySlider = document.getElementById('simplify');
        
        const lowValue = document.getElementById('lowValue');
        const highValue = document.getElementById('highValue');
        const widthValue = document.getElementById('widthValue');
        const simplifyValue = document.getElementById('simplifyValue');
        
        edgeLowSlider.addEventListener('input', (e) => {
            lowValue.textContent = e.target.value;
            if (currentImage) updateEdgePreview();
        });
        
        edgeHighSlider.addEventListener('input', (e) => {
            highValue.textContent = e.target.value;
            if (currentImage) updateEdgePreview();
        });
        
        widthSlider.addEventListener('input', (e) => {
            widthValue.textContent = e.target.value;
        });
        
        simplifySlider.addEventListener('input', (e) => {
            simplifyValue.textContent = e.target.value;
        });
        
        uploadArea.addEventListener('click', () => fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length) {
                handleFile(e.dataTransfer.files[0]);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length) {
                handleFile(e.target.files[0]);
            }
        });
        
        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    currentImage = img;
                    updateEdgePreview();
                    convertBtn.disabled = false;
                    showStatus('Image loaded! Adjust settings and click Convert.', 'success');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function updateEdgePreview() {
            if (!currentImage) return;
            
            const maxSize = 400;
            const scale = Math.min(1, maxSize / Math.max(currentImage.width, currentImage.height));
            const width = Math.round(currentImage.width * scale);
            const height = Math.round(currentImage.height * scale);
            
            // Original
            originalCanvas.width = width;
            originalCanvas.height = height;
            const ctx1 = originalCanvas.getContext('2d');
            ctx1.drawImage(currentImage, 0, 0, width, height);
            
            // Edge detection
            const imageData = ctx1.getImageData(0, 0, width, height);
            const lowThreshold = parseInt(edgeLowSlider.value);
            const highThreshold = parseInt(edgeHighSlider.value);
            const edges = cannyEdgeDetection(imageData, lowThreshold, highThreshold);
            
            edgeCanvas.width = width;
            edgeCanvas.height = height;
            const ctx2 = edgeCanvas.getContext('2d');
            const edgeImageData = ctx2.createImageData(width, height);
            
            for (let i = 0; i < width * height; i++) {
                const val = edges[i] ? 0 : 255;
                edgeImageData.data[i*4] = val;
                edgeImageData.data[i*4+1] = val;
                edgeImageData.data[i*4+2] = val;
                edgeImageData.data[i*4+3] = 255;
            }
            
            ctx2.putImageData(edgeImageData, 0, 0);
            previewSection.classList.remove('hidden');
        }
        
        function showStatus(message, type) {
            status.textContent = message;
            status.className = `status ${type}`;
            status.classList.remove('hidden');
        }
        
        function updateProgress(percent) {
            progressBar.style.width = percent + '%';
            progressBar.textContent = Math.round(percent) + '%';
        }
        
        function cannyEdgeDetection(imageData, lowThreshold, highThreshold) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            
            // Convert to grayscale
            const gray = new Float32Array(width * height);
            for (let i = 0; i < width * height; i++) {
                const idx = i * 4;
                gray[i] = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
            }
            
            // Gaussian blur
            const blurred = gaussianBlur(gray, width, height);
            
            // Sobel edge detection
            const gradientMag = new Float32Array(width * height);
            const gradientDir = new Float32Array(width * height);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const gx = 
                        -blurred[(y-1)*width + (x-1)] + blurred[(y-1)*width + (x+1)] +
                        -2*blurred[y*width + (x-1)] + 2*blurred[y*width + (x+1)] +
                        -blurred[(y+1)*width + (x-1)] + blurred[(y+1)*width + (x+1)];
                    
                    const gy = 
                        -blurred[(y-1)*width + (x-1)] - 2*blurred[(y-1)*width + x] - blurred[(y-1)*width + (x+1)] +
                        blurred[(y+1)*width + (x-1)] + 2*blurred[(y+1)*width + x] + blurred[(y+1)*width + (x+1)];
                    
                    const idx = y * width + x;
                    gradientMag[idx] = Math.sqrt(gx*gx + gy*gy);
                    gradientDir[idx] = Math.atan2(gy, gx);
                }
            }
            
            // Non-maximum suppression
            const suppressed = new Float32Array(width * height);
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    const angle = gradientDir[idx];
                    const mag = gradientMag[idx];
                    
                    let neighbor1, neighbor2;
                    if ((angle >= -Math.PI/8 && angle < Math.PI/8) || (angle >= 7*Math.PI/8 || angle < -7*Math.PI/8)) {
                        neighbor1 = gradientMag[y*width + (x-1)];
                        neighbor2 = gradientMag[y*width + (x+1)];
                    } else if ((angle >= Math.PI/8 && angle < 3*Math.PI/8) || (angle >= -7*Math.PI/8 && angle < -5*Math.PI/8)) {
                        neighbor1 = gradientMag[(y-1)*width + (x+1)];
                        neighbor2 = gradientMag[(y+1)*width + (x-1)];
                    } else if ((angle >= 3*Math.PI/8 && angle < 5*Math.PI/8) || (angle >= -5*Math.PI/8 && angle < -3*Math.PI/8)) {
                        neighbor1 = gradientMag[(y-1)*width + x];
                        neighbor2 = gradientMag[(y+1)*width + x];
                    } else {
                        neighbor1 = gradientMag[(y-1)*width + (x-1)];
                        neighbor2 = gradientMag[(y+1)*width + (x+1)];
                    }
                    
                    if (mag >= neighbor1 && mag >= neighbor2) {
                        suppressed[idx] = mag;
                    }
                }
            }
            
            // Double thresholding
            const edges = new Uint8Array(width * height);
            for (let i = 0; i < width * height; i++) {
                if (suppressed[i] >= highThreshold) {
                    edges[i] = 2; // Strong edge
                } else if (suppressed[i] >= lowThreshold) {
                    edges[i] = 1; // Weak edge
                }
            }
            
            // Edge tracking by hysteresis
            const final = new Uint8Array(width * height);
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    if (edges[idx] === 2) {
                        final[idx] = 1;
                        // Check neighbors
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nidx = (y+dy)*width + (x+dx);
                                if (edges[nidx] === 1) {
                                    final[nidx] = 1;
                                }
                            }
                        }
                    }
                }
            }
            
            return final;
        }
        
        function gaussianBlur(data, width, height) {
            const kernel = [1/16, 2/16, 1/16, 2/16, 4/16, 2/16, 1/16, 2/16, 1/16];
            const result = new Float32Array(width * height);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let sum = 0;
                    let kidx = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            sum += data[(y+ky)*width + (x+kx)] * kernel[kidx++];
                        }
                    }
                    result[y*width + x] = sum;
                }
            }
            
            return result;
        }
        
        function simplifyPath(points, tolerance) {
            if (points.length < 3) return points;
            
            function perpendicularDistance(point, lineStart, lineEnd) {
                const dx = lineEnd.x - lineStart.x;
                const dy = lineEnd.y - lineStart.y;
                const mag = Math.sqrt(dx*dx + dy*dy);
                if (mag === 0) return Math.sqrt((point.x - lineStart.x)**2 + (point.y - lineStart.y)**2);
                const u = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (mag * mag);
                const ix = lineStart.x + u * dx;
                const iy = lineStart.y + u * dy;
                return Math.sqrt((point.x - ix)**2 + (point.y - iy)**2);
            }
            
            function simplifyRecursive(start, end) {
                let maxDist = 0;
                let maxIndex = 0;
                
                for (let i = start + 1; i < end; i++) {
                    const dist = perpendicularDistance(points[i], points[start], points[end]);
                    if (dist > maxDist) {
                        maxDist = dist;
                        maxIndex = i;
                    }
                }
                
                if (maxDist > tolerance) {
                    const left = simplifyRecursive(start, maxIndex);
                    const right = simplifyRecursive(maxIndex, end);
                    return [...left.slice(0, -1), ...right];
                } else {
                    return [points[start], points[end]];
                }
            }
            
            return simplifyRecursive(0, points.length - 1);
        }
        
        convertBtn.addEventListener('click', () => {
            if (!currentImage) return;
            
            showStatus('Processing...', 'info');
            progress.classList.remove('hidden');
            updateProgress(10);
            convertBtn.disabled = true;
            
            setTimeout(() => {
                const outputSize = parseInt(widthSlider.value);
                const lowThreshold = parseInt(edgeLowSlider.value);
                const highThreshold = parseInt(edgeHighSlider.value);
                const simplification = parseFloat(simplifySlider.value);
                
                const aspectRatio = currentImage.height / currentImage.width;
                const width = outputSize;
                const height = Math.round(outputSize * aspectRatio);
                
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(currentImage, 0, 0, width, height);
                
                updateProgress(30);
                const imageData = ctx.getImageData(0, 0, width, height);
                const edges = cannyEdgeDetection(imageData, lowThreshold, highThreshold);
                
                updateProgress(50);
                
                // Extract edge points
                const points = [];
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (edges[y * width + x]) {
                            points.push({x, y: height - y}); // Flip Y for Desmos
                        }
                    }
                }
                
                updateProgress(70);
                
                // Group points into lines (simple row-based grouping)
                const expressions = [];
                const rowGroups = {};
                
                points.forEach(p => {
                    const rowKey = Math.round(p.y / simplification) * simplification;
                    if (!rowGroups[rowKey]) rowGroups[rowKey] = [];
                    rowGroups[rowKey].push(p);
                });
                
                updateProgress(85);
                
                // Create expressions
                Object.values(rowGroups).forEach(group => {
                    if (group.length > 2) {
                        // Sort by x
                        group.sort((a, b) => a.x - b.x);
                        const simplified = simplifyPath(group, simplification);
                        
                        if (simplified.length > 1) {
                            const xs = simplified.map(p => p.x).join(',');
                            const ys = simplified.map(p => p.y).join(',');
                            expressions.push(`([${xs}],[${ys}])`);
                        }
                    }
                });
                
                updateProgress(100);
                
                displayExpressions(expressions);
                showStatus(`âœ… Generated ${expressions.length} expressions with ${points.length} edge points!`, 'success');
                
                setTimeout(() => {
                    progress.classList.add('hidden');
                }, 2000);
                
                convertBtn.disabled = false;
                outputSection.classList.remove('hidden');
                outputSection.scrollIntoView({ behavior: 'smooth' });
            }, 100);
        });
        
        function displayExpressions(expressions) {
            expressionsList.innerHTML = '';
            expressions.forEach(expr => {
                const div = document.createElement('div');
                div.className = 'expression';
                div.textContent = expr;
                div.addEventListener('click', () => {
                    navigator.clipboard.writeText(expr);
                    div.style.background = '#e8f5e9';
                    setTimeout(() => div.style.background = '#f8f9ff', 500);
                });
                expressionsList.appendChild(div);
            });
            window.currentExpressions = expressions;
        }
        
        document.getElementById('copyAllBtn').addEventListener('click', () => {
            const allText = window.currentExpressions.join('\n');
            navigator.clipboard.writeText(allText);
            showStatus('ðŸ“‹ Copied all expressions to clipboard!', 'success');
        });
        
        document.getElementById('downloadBtn').addEventListener('click', () => {
            const allText = window.currentExpressions.join('\n');
            const blob = new Blob([allText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'desmos-outlines.txt';
            a.click();
            URL.revokeObjectURL(url);
            showStatus('ðŸ’¾ Downloaded!', 'success');
        });
    </script>
</body>
</html>